namespace RenovationRumble.Logic.Generators
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Helpers;
    using Microsoft.CodeAnalysis;

    /// <summary>
    /// Scans for classes implementing ICommandExecutor with TCommand : CommandDataModel
    /// and generates a registry to register them via new() without reflection.
    /// </summary>
    [Generator(LanguageNames.CSharp)]
    public sealed class CommandExecutorGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassCollectorReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not ClassCollectorReceiver receiver)
                return;

            var compilation = context.Compilation;

            var executorInterface = compilation.GetTypeByMetadataName(ProjectMetadata.ExecutorInterface);
            var commandBase = compilation.GetTypeByMetadataName(ProjectMetadata.CommandBase);
            var runnerType = compilation.GetTypeByMetadataName(ProjectMetadata.CommandRunner);

            if (executorInterface is null || commandBase is null || runnerType is null)
                return;

            var pairs = new List<(INamedTypeSymbol executorType, INamedTypeSymbol commandType)>();
            var diagnostics = new List<Diagnostic>();

            foreach (var cls in receiver.Candidates)
            {
                var model = compilation.GetSemanticModel(cls.SyntaxTree);
                if (model.GetDeclaredSymbol(cls) is not INamedTypeSymbol executorType)
                    continue;

                if (executorType.IsAbstract)
                    continue;

                if (executorType.TypeKind != TypeKind.Class)
                    continue;

                // Gather all implemented ICommandExecutor<T>
                var executorIfaces = executorType.AllInterfaces
                    .Where(i => SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, executorInterface))
                    .ToList();

                if (executorIfaces.Count == 0)
                    continue;

                // A single class must not implement multiple ICommandExecutor<T>
                if (executorIfaces.Count > 1)
                {
                    diagnostics.Add(Diagnostic.Create(Diagnostics.MultipleExecutorInterfaces, RoselynHelper.GetFirstLocation(executorType),
                        executorType.ToDisplayString()));
                    continue;
                }

                var singleIface = executorIfaces[0];
                if (singleIface.TypeArguments.Length != 1)
                    continue;

                if (singleIface.TypeArguments[0] is not INamedTypeSymbol commandType)
                    continue;

                // Make sure TCommand : CommandDataModel
                if (!RoselynHelper.InheritsFrom(commandType, commandBase))
                    continue;

                // Must have public parameterless ctor
                if (!RoselynHelper.HasPublicParameterlessCtor(executorType))
                {
                    diagnostics.Add(Diagnostic.Create(Diagnostics.MissingPublicParameterlessCtor, RoselynHelper.GetFirstLocation(executorType),
                        executorType.ToDisplayString()));
                    continue;
                }

                pairs.Add((executorType, commandType));
            }

            // Duplicate executors for the same TCommand not allowed
            foreach (var group in pairs.GroupBy(p => p.commandType, SymbolEqualityComparer.Default))
            {
                if (group.Count() > 1)
                {
                    var cmdName = group.Key.ToDisplayString();
                    var execList = string.Join(", ", group.Select(g => g.executorType.ToDisplayString()));
                    diagnostics.Add(Diagnostic.Create(Diagnostics.DuplicateExecutorForCommand, RoselynHelper.GetFirstLocation(group.First().executorType), cmdName, execList));
                }
            }

            foreach (var diagnostic in diagnostics)
                context.ReportDiagnostic(diagnostic);

            var source = EmitRegistry(pairs
                .GroupBy(p => p.commandType, SymbolEqualityComparer.Default)
                .Select(g => g.First())
                .OrderBy(p => p.commandType.Name)
                .ThenBy(p => p.executorType.Name));

            context.AddSource("CommandExecutorRegistry.g.cs", source);
        }

        private static string EmitRegistry(IEnumerable<(INamedTypeSymbol executorType, INamedTypeSymbol commandType)> items)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// This file has been autogenerated. Please do not edit manually.");
            sb.AppendLine("namespace RenovationRumble.Logic.Runtime.Executors");
            sb.AppendLine("{");
            sb.AppendLine("    using RenovationRumble.Logic.Runtime.Runner;");
            sb.AppendLine("    using RenovationRumble.Logic.Data.Commands;");
            sb.AppendLine();
            sb.AppendLine("    public static partial class CommandExecutorRegistry");
            sb.AppendLine("    {");
            sb.AppendLine("        public static void RegisterAll(CommandRunner runner)");
            sb.AppendLine("        {");

            foreach (var (executorType, commandType) in items)
            {
                var executorName = executorType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var commandName = commandType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                sb.AppendLine($"            // {commandType.Name} -> {executorType.Name}");
                sb.AppendLine($"            runner.Register<{commandName}>(new {executorName}());");
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }
    }
}